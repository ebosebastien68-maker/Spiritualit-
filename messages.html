<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Messagerie V2</title>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: #f5f7fa; height: 100vh; overflow: hidden; }
        
        .messages-wrapper { height: 100vh; display: flex; flex-direction: column; }
        
        /* Header */
        .messages-header { background: white; padding: 15px 20px; box-shadow: 0 2px 10px rgba(0,0,0,0.08); display: flex; justify-content: space-between; align-items: center; z-index: 100; }
        .messages-header h1 { color: #333; font-size: 20px; display: flex; align-items: center; gap: 10px; }
        .messages-header h1 i { color: #667eea; }
        
        .header-actions { display: flex; gap: 10px; }
        .action-btn { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border: none; padding: 10px 20px; border-radius: 20px; cursor: pointer; font-weight: 600; display: flex; align-items: center; gap: 8px; transition: transform 0.2s; font-size: 14px; }
        .action-btn:hover { transform: translateY(-2px); box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4); }
        .action-btn.secondary { background: #f0f0f0; color: #667eea; }
        
        /* Container principal */
        .messages-container { flex: 1; overflow: hidden; background: white; margin: 15px; border-radius: 15px; box-shadow: 0 2px 15px rgba(0,0,0,0.08); display: flex; flex-direction: column; position: relative; }
        
        /* Zone de chat principale */
        .chat-area { flex: 1; display: flex; flex-direction: column; min-height: 0; }
        
        .chat-header { padding: 15px 20px; border-bottom: 1px solid #e0e0e0; display: flex; align-items: center; gap: 12px; background: #fafbfc; flex-shrink: 0; }
        .chat-avatar { width: 45px; height: 45px; border-radius: 50%; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); display: flex; align-items: center; justify-content: center; color: white; font-weight: bold; font-size: 16px; flex-shrink: 0; }
        .chat-user-info { flex: 1; }
        .chat-user-info h3 { color: #333; font-size: 15px; margin-bottom: 2px; }
        .chat-user-info p { color: #999; font-size: 12px; }
        #typing-indicator { color: #667eea; font-style: italic; font-size: 12px; height: 14px; transition: opacity 0.3s; }

        .chat-messages { flex: 1; overflow-y: auto; overflow-x: hidden; padding: 20px; display: flex; flex-direction: column; gap: 12px; background: #f5f7fa; min-height: 0; }
        
        .message-bubble { max-width: 75%; padding: 10px 15px; border-radius: 18px; word-wrap: break-word; animation: slideIn 0.3s ease; display: flex; flex-direction: column; }
        @keyframes slideIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        
        .message-sent { align-self: flex-end; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border-bottom-right-radius: 4px; }
        .message-received { align-self: flex-start; background: white; color: #333; border-bottom-left-radius: 4px; box-shadow: 0 2px 8px rgba(0,0,0,0.08); }
        .message-text { margin-bottom: 5px; line-height: 1.4; font-size: 14px; }
        .message-meta { display: flex; align-items: center; justify-content: flex-end; gap: 5px; align-self: flex-end; }
        .message-time { font-size: 10px; opacity: 0.8; }
        .message-status { font-size: 12px; opacity: 0.9; }
        .message-status.read { color: #4fc3f7; }
        .message-image { max-width: 100%; max-height: 250px; border-radius: 12px; margin-top: 8px; cursor: pointer; }
        
        .chat-input-area { padding: 15px 20px; border-top: 1px solid #e0e0e0; display: flex; flex-direction: column; gap: 10px; background: white; flex-shrink: 0; }
        .main-input-row { display: flex; gap: 10px; align-items: center; }
        .attach-btn { background: #f0f0f0; border: none; color: #667eea; width: 40px; height: 40px; border-radius: 50%; font-size: 18px; cursor: pointer; transition: all 0.3s; flex-shrink: 0; display: flex; align-items: center; justify-content: center; }
        .attach-btn:hover { background: #e0e0e0; transform: scale(1.05); }
        
        .input-wrapper { flex: 1; position: relative; display: flex; align-items: center; }
        .message-input { width: 100%; padding: 12px 20px; border: 2px solid #e0e0e0; border-radius: 25px; font-size: 14px; font-family: inherit; transition: border-color 0.3s; }
        .message-input:focus { outline: none; border-color: #667eea; }
        
        .send-btn { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border: none; width: 40px; height: 40px; border-radius: 50%; cursor: pointer; font-size: 16px; flex-shrink: 0; transition: all 0.3s; display: flex; align-items: center; justify-content: center; }
        .send-btn:hover { transform: scale(1.1); box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4); }
        .send-btn:disabled { opacity: 0.5; cursor: not-allowed; transform: none; box-shadow: none; }
        
        #image-preview-container { display: none; align-items: center; gap: 10px; background: #f0f0ff; padding: 8px; border-radius: 12px; }
        #image-preview { max-height: 50px; border-radius: 8px; }
        #image-preview-name { font-size: 12px; color: #555; flex-grow: 1; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        #cancel-image-btn { background: #ddd; border: none; width: 20px; height: 20px; border-radius: 50%; cursor: pointer; font-size: 12px; }

        .empty-state { flex: 1; display: flex; flex-direction: column; align-items: center; justify-content: center; color: #999; background: #f5f7fa; }
        .empty-state i { font-size: 60px; margin-bottom: 15px; color: #ddd; }
        .empty-state h3 { font-size: 16px; color: #666; margin-bottom: 8px; }
        
        /* Modal (pas de changement) */
        .modal { display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); z-index: 1000; align-items: center; justify-content: center; }
        .modal.show { display: flex; }
        .modal-content { background: white; border-radius: 20px; width: 95%; max-width: 450px; max-height: 85vh; overflow: hidden; display: flex; flex-direction: column; animation: modalSlide 0.3s ease; }
        @keyframes modalSlide { from { opacity: 0; transform: scale(0.9); } to { opacity: 1; transform: scale(1); } }
        .modal-header { padding: 20px; border-bottom: 1px solid #e0e0e0; display: flex; justify-content: space-between; align-items: center; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; }
        .modal-header h3 { font-size: 18px; display: flex; align-items: center; gap: 10px; }
        .close-modal { background: rgba(255,255,255,0.2); border: none; width: 32px; height: 32px; border-radius: 50%; font-size: 20px; color: white; cursor: pointer; }
        .modal-search { padding: 15px; border-bottom: 1px solid #e0e0e0; }
        .modal-search input { width: 100%; padding: 10px 15px 10px 40px; border: 2px solid #e0e0e0; border-radius: 20px; font-size: 14px; background: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="%23999" stroke-width="2"><circle cx="11" cy="11" r="8"/><path d="m21 21-4.35-4.35"/></svg>') no-repeat 12px center; }
        .list-container { flex: 1; overflow-y: auto; }
        .list-item { padding: 12px 15px; border-bottom: 1px solid #f0f0f0; cursor: pointer; display: flex; align-items: center; gap: 12px; transition: background 0.2s; }
        .list-item:hover { background: #f8f9ff; }
        .item-avatar { width: 45px; height: 45px; border-radius: 50%; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); display: flex; align-items: center; justify-content: center; color: white; font-weight: bold; font-size: 16px; flex-shrink: 0; }
        .item-info { flex: 1; min-width: 0; }
        .item-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px; }
        .item-name { font-weight: 600; color: #333; font-size: 14px; }
        .item-role { font-size: 10px; color: #667eea; background: #f0f0ff; padding: 2px 6px; border-radius: 8px; }
        .item-time { font-size: 11px; color: #999; }
        .item-preview { font-size: 12px; color: #999; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .item-unread { background: #667eea; color: white; border-radius: 10px; padding: 2px 7px; font-size: 10px; font-weight: bold; flex-shrink: 0; }
        
        /* Scrollbar (pas de changement) */
        .chat-messages::-webkit-scrollbar { width: 8px; }
        .chat-messages::-webkit-scrollbar-track { background: #f1f1f1; border-radius: 10px; }
        .chat-messages::-webkit-scrollbar-thumb { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border-radius: 10px; }
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: #f1f1f1; }
        ::-webkit-scrollbar-thumb { background: #c1c1c1; border-radius: 3px; }
    </style>
</head>
<body>
    <div class="messages-wrapper">
        <div class="messages-header">
            <h1><i class="fas fa-comments"></i> <span id="header-title">Messagerie</span></h1>
            <div class="header-actions">
                <button class="action-btn secondary" onclick="openConversationsModal()"><i class="fas fa-list"></i><span>Conversations</span></button>
                <button class="action-btn" onclick="openContactsModal()"><i class="fas fa-user-plus"></i><span id="contacts-btn-text">Contacts</span></button>
            </div>
        </div>
        <div class="messages-container">
            <div class="chat-area" id="chat-area">
                <div class="empty-state"><i class="fas fa-spinner fa-spin"></i><h3>Chargement...</h3></div>
            </div>
        </div>
    </div>
    <div class="modal" id="conversations-modal"> </div>
    <div class="modal" id="contacts-modal"> </div>

    <script src="supabaseClient.js"></script>
    <script>
        const { supabase, getCurrentUser, getUserProfile } = window.supabaseClient;
        
        // State Management
        const state = {
            currentUser: null,
            userProfile: null,
            currentChatUser: null,
            realtimeChannel: null,
            conversationsCache: [],
            contactsCache: [],
            typingTimeout: null,
            imageFile: null
        };

        // DOM Elements
        const DOMElements = {
            chatArea: document.getElementById('chat-area'),
            conversationsModal: document.getElementById('conversations-modal'),
            contactsModal: document.getElementById('contacts-modal'),
            conversationsList: document.getElementById('conversations-list'),
            contactsList: document.getElementById('contacts-list')
        };
        
        // --- INITIALIZATION ---
        window.addEventListener('DOMContentLoaded', async () => {
            state.currentUser = await getCurrentUser();
            if (!state.currentUser) {
                window.location.href = 'connexion.html';
                return;
            }
            state.userProfile = await getUserProfile(state.currentUser.id);
            await initInterface();
            setupEventListeners();
        });

        function setupEventListeners() {
            document.getElementById('search-conversations').addEventListener('input', (e) => filterList('conversations', e.target.value));
            document.getElementById('search-contacts').addEventListener('input', (e) => filterList('contacts', e.target.value));
            DOMElements.conversationsModal.addEventListener('click', (e) => { if (e.target === DOMElements.conversationsModal) closeConversationsModal(); });
            DOMElements.contactsModal.addEventListener('click', (e) => { if (e.target === DOMElements.contactsModal) closeContactsModal(); });
        }

        async function initInterface() {
            // Logic unchanged, just uses state object
            if (state.userProfile.role === 'user') {
                document.getElementById('contacts-btn-text').textContent = 'Admins';
                document.getElementById('contacts-modal-title').textContent = 'Administrateurs';
                await initUserChat();
            } else {
                document.getElementById('contacts-btn-text').textContent = 'Contacts';
                document.getElementById('contacts-modal-title').textContent = 'Tous les contacts';
                await initAdminChat();
            }
        }
        
        async function initUserChat() {
            // Logic unchanged
            const storedAdminId = localStorage.getItem(`default_admin_${state.currentUser.id}`);
            let defaultAdmin = null;

            if (storedAdminId) {
                const { data } = await supabase.from('users_profile').select('*').eq('user_id', storedAdminId).eq('role', 'admin').single();
                defaultAdmin = data;
            }

            if (!defaultAdmin) {
                const { data: admins } = await supabase.from('users_profile').select('user_id, prenom, nom, role').eq('role', 'admin').limit(10);
                if (admins && admins.length > 0) {
                    defaultAdmin = admins[Math.floor(Math.random() * admins.length)];
                    localStorage.setItem(`default_admin_${state.currentUser.id}`, defaultAdmin.user_id);
                }
            }

            if (defaultAdmin) {
                openChat(defaultAdmin);
            } else {
                showEmptyState('Aucun administrateur disponible');
            }
            await loadConversations();
        }

        async function initAdminChat() {
            await loadConversations();
            if (state.conversationsCache.length > 0) {
                openChat(state.conversationsCache[0].user);
            } else {
                showEmptyState('Aucune conversation', 'Attendez qu\'un utilisateur vous contacte');
            }
        }

        // --- DATA LOADING & CACHING ---
        async function loadConversations() { /* Logic mostly unchanged, just adapted for state */
            const { data: messages, error } = await supabase.from('messages')
                .select('message_id, sender_id, receiver_id, texte, date_created, read_status, image_url')
                .or(`sender_id.eq.${state.currentUser.id},receiver_id.eq.${state.currentUser.id}`)
                .order('date_created', { ascending: false }).limit(200);

            if (error) { console.error('Error loading conversations:', error); return; }
            
            const userIds = [...new Set(messages.map(msg => msg.sender_id === state.currentUser.id ? msg.receiver_id : msg.sender_id))];
            if (userIds.length === 0) { state.conversationsCache = []; return; }

            const { data: users, error: usersError } = await supabase.from('users_profile').select('user_id, prenom, nom, role').in('user_id', userIds);
            if (usersError) { console.error('Error fetching users:', usersError); return; }
            
            const usersMap = users.reduce((acc, u) => ({ ...acc, [u.user_id]: u }), {});
            const conversations = {};

            messages.forEach(msg => {
                const otherId = msg.sender_id === state.currentUser.id ? msg.receiver_id : msg.sender_id;
                const otherUser = usersMap[otherId];
                if (!otherUser || (state.userProfile.role === 'user' && otherUser.role !== 'admin')) return;

                if (!conversations[otherId]) {
                    conversations[otherId] = { user: otherUser, lastMessage: msg, unread: 0 };
                }
                if (msg.receiver_id === state.currentUser.id && !msg.read_status) {
                    conversations[otherId].unread++;
                }
            });
            state.conversationsCache = Object.values(conversations).sort((a, b) => new Date(b.lastMessage.date_created) - new Date(a.lastMessage.date_created));
        }

        async function loadContacts() { /* Logic unchanged */ }

        async function loadMessages(otherUserId) {
            const { data, error } = await supabase.from('messages')
                .select('*, sender:sender_id(prenom, nom)')
                .or(`and(sender_id.eq.${state.currentUser.id},receiver_id.eq.${otherUserId}),and(sender_id.eq.${otherUserId},receiver_id.eq.${state.currentUser.id})`)
                .order('date_created', { ascending: true });
            if (error) { console.error('Error loading messages:', error); return; }
            
            const chatMessagesContainer = document.getElementById('chat-messages');
            chatMessagesContainer.innerHTML = ''; // Clear before loading
            data.forEach(msg => appendMessage(msg, { prepend: false, scroll: false }));
            scrollToBottom(chatMessagesContainer);
        }

        // --- CHAT UI & LOGIC ---
        function openChat(user) {
            if (state.currentChatUser?.user_id === user.user_id) return;
            state.currentChatUser = user;
            
            DOMElements.chatArea.innerHTML = `
                <div class="chat-header">
                    <div class="chat-avatar">${user.prenom[0]}${user.nom[0]}</div>
                    <div class="chat-user-info">
                        <h3>${user.prenom} ${user.nom}</h3>
                        <p id="typing-indicator"></p>
                    </div>
                </div>
                <div class="chat-messages" id="chat-messages"></div>
                <div class="chat-input-area">
                     <div id="image-preview-container">
                        <img id="image-preview" src="" alt="Aper√ßu">
                        <span id="image-preview-name"></span>
                        <button id="cancel-image-btn" onclick="cancelImageSelection()">√ó</button>
                    </div>
                    <div class="main-input-row">
                        <input type="file" id="image-input" accept="image/*" style="display: none;">
                        <button class="attach-btn" onclick="document.getElementById('image-input').click()"><i class="fas fa-paperclip"></i></button>
                        <div class="input-wrapper">
                            <input type="text" class="message-input" id="message-input" placeholder="Votre message..." autocomplete="off">
                        </div>
                        <button class="send-btn" id="send-btn"><i class="fas fa-paper-plane"></i></button>
                    </div>
                </div>
            `;
            
            loadMessages(user.user_id);
            markMessagesAsRead(user.user_id);
            subscribeToChannel(user.user_id);

            // Add event listeners for the new chat area
            const messageInput = document.getElementById('message-input');
            const sendBtn = document.getElementById('send-btn');
            const imageInput = document.getElementById('image-input');
            
            messageInput.addEventListener('input', handleTyping);
            messageInput.addEventListener('keypress', handleKeyPress);
            sendBtn.addEventListener('click', () => sendMessage());
            imageInput.addEventListener('change', handleImageSelect);
        }

        function appendMessage(msg, options = { prepend: false, scroll: true }) {
            const container = document.getElementById('chat-messages');
            if (!container) return;

            const isSent = msg.sender_id === state.currentUser.id;
            const messageId = msg.message_id || msg.temp_id;

            // Avoid duplicating optimistic message
            if (document.getElementById(`msg-${messageId}`)) return;

            const div = document.createElement('div');
            div.className = `message-bubble ${isSent ? 'message-sent' : 'message-received'}`;
            div.id = `msg-${messageId}`;

            let contentHTML = '';
            if (msg.texte) contentHTML += `<div class="message-text">${escapeHtml(msg.texte)}</div>`;
            if (msg.image_url) contentHTML += `<img src="${msg.image_url}" class="message-image" onclick="window.open('${msg.image_url}', '_blank')">`;

            div.innerHTML = `
                ${contentHTML}
                <div class="message-meta">
                    <span class="message-time">${formatTime(msg.date_created)}</span>
                    ${isSent ? `<span class="message-status">${getMessageStatusIcon(msg)}</span>` : ''}
                </div>
            `;
            
            const shouldScroll = container.scrollHeight - container.scrollTop <= container.clientHeight + 150;
            
            if (options.prepend) container.prepend(div);
            else container.appendChild(div);

            if (options.scroll && shouldScroll) scrollToBottom(container);
        }

        async function sendMessage() {
            const input = document.getElementById('message-input');
            const sendBtn = document.getElementById('send-btn');
            const attachBtn = document.querySelector('.attach-btn');

            const text = input.value.trim();
            const imageFile = state.imageFile;

            if (!text && !imageFile) return;

            const tempId = `temp_${Date.now()}`;
            const optimisticMessage = {
                temp_id: tempId,
                sender_id: state.currentUser.id,
                texte: text,
                image_url: imageFile ? URL.createObjectURL(imageFile) : null,
                date_created: new Date().toISOString(),
                status: 'sending'
            };

            appendMessage(optimisticMessage);
            input.value = '';
            cancelImageSelection(); // Clear preview

            // Disable form while sending
            input.disabled = true;
            sendBtn.disabled = true;
            attachBtn.disabled = true;
            sendBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';

            try {
                let imageUrl = null;
                if (imageFile) {
                    const fileName = `${Date.now()}_${imageFile.name}`;
                    const { error: uploadError } = await supabase.storage.from('messages-images').upload(fileName, imageFile);
                    if (uploadError) throw uploadError;
                    const { data } = supabase.storage.from('messages-images').getPublicUrl(fileName);
                    imageUrl = data.publicUrl;
                }

                const { data: [newMessage], error } = await supabase.from('messages').insert({
                    sender_id: state.currentUser.id,
                    receiver_id: state.currentChatUser.user_id,
                    texte: text || null,
                    image_url: imageUrl
                }).select();
                if (error) throw error;
                
                updateMessageStatus(tempId, newMessage);

            } catch (error) {
                console.error('Send message error:', error);
                updateMessageStatus(tempId, { ...optimisticMessage, status: 'failed' });
            } finally {
                // Re-enable form
                input.disabled = false;
                sendBtn.disabled = false;
                attachBtn.disabled = false;
                sendBtn.innerHTML = '<i class="fas fa-paper-plane"></i>';
                input.focus();
            }
        }
        
        // --- REALTIME & SUBSCRIPTIONS ---
        function subscribeToChannel(otherUserId) {
            if (state.realtimeChannel) {
                supabase.removeChannel(state.realtimeChannel);
                state.realtimeChannel = null;
            }

            const channelName = `chat-${[state.currentUser.id, otherUserId].sort().join('-')}`;
            state.realtimeChannel = supabase.channel(channelName, {
                config: { broadcast: { self: true } }
            });

            state.realtimeChannel
                .on('postgres_changes', { event: 'INSERT', schema: 'public', table: 'messages' }, payload => {
                    // Only process if it's for the current chat and not my own optimistic message
                    if ((payload.new.sender_id === otherUserId && payload.new.receiver_id === state.currentUser.id) ||
                        (payload.new.sender_id === state.currentUser.id && payload.new.receiver_id === otherUserId && !document.getElementById(`msg-${payload.new.message_id}`))) {
                        appendMessage(payload.new);
                        if (payload.new.sender_id === otherUserId) {
                            markMessagesAsRead(otherUserId);
                        }
                    }
                })
                .on('postgres_changes', { event: 'UPDATE', schema: 'public', table: 'messages' }, payload => {
                    // If a message was updated to 'read'
                    if (payload.new.receiver_id === otherUserId && payload.new.sender_id === state.currentUser.id) {
                         updateAllMyMessageStatusesAsRead();
                    }
                })
                .on('broadcast', { event: 'typing' }, ({ payload }) => {
                    if (payload.userId === otherUserId) {
                         handleTypingIndicator(payload.isTyping);
                    }
                })
                .subscribe();
        }
        
        async function markMessagesAsRead(otherUserId) {
            await supabase
                .from('messages')
                .update({ read_status: true })
                .eq('sender_id', otherUserId)
                .eq('receiver_id', state.currentUser.id)
                .eq('read_status', false); // Only update unread ones
        }

        // --- UI UTILITIES ---
        function getMessageStatusIcon(msg) {
            if (msg.status === 'failed') return '‚ö†Ô∏è';
            if (msg.status === 'sending') return 'üïí';
            if (msg.read_status) return '<i class="fas fa-check-double" style="color: #4fc3f7;"></i>';
            return '<i class="fas fa-check"></i>';
        }

        function updateMessageStatus(tempId, newMessage) {
            const el = document.getElementById(`msg-${tempId}`);
            if (el) {
                el.id = `msg-${newMessage.message_id}`;
                const statusEl = el.querySelector('.message-status');
                if (statusEl) {
                    statusEl.innerHTML = getMessageStatusIcon(newMessage);
                }
            }
        }
        
        function updateAllMyMessageStatusesAsRead() {
             const sentMessages = document.querySelectorAll('.message-sent .message-status');
             sentMessages.forEach(el => {
                // Update only if not already read
                if (!el.innerHTML.includes('fa-check-double')) {
                    el.innerHTML = '<i class="fas fa-check-double" style="color: #4fc3f7;"></i>';
                }
             });
        }
        
        function handleTyping() {
            if (!state.realtimeChannel) return;
            
            if (!state.typingTimeout) {
                state.realtimeChannel.send({ type: 'broadcast', event: 'typing', payload: { isTyping: true, userId: state.currentUser.id } });
            } else {
                clearTimeout(state.typingTimeout);
            }
            
            state.typingTimeout = setTimeout(() => {
                state.realtimeChannel.send({ type: 'broadcast', event: 'typing', payload: { isTyping: false, userId: state.currentUser.id } });
                state.typingTimeout = null;
            }, 1500);
        }
        
        function handleTypingIndicator(isTyping) {
            const indicator = document.getElementById('typing-indicator');
            if(indicator) indicator.textContent = isTyping ? 'est en train d\'√©crire...' : '';
        }

        function handleImageSelect(event) {
            const file = event.target.files[0];
            if (!file) return;

            if (file.size > 5 * 1024 * 1024) { // 5MB limit
                alert("L'image est trop grande (max 5MB).");
                return;
            }
            state.imageFile = file;
            const previewContainer = document.getElementById('image-preview-container');
            const previewImg = document.getElementById('image-preview');
            const previewName = document.getElementById('image-preview-name');
            
            previewImg.src = URL.createObjectURL(file);
            previewName.textContent = file.name;
            previewContainer.style.display = 'flex';
        }
        
        function cancelImageSelection() {
            state.imageFile = null;
            document.getElementById('image-input').value = ''; // Reset file input
            document.getElementById('image-preview-container').style.display = 'none';
        }

        function handleKeyPress(event) {
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault();
                sendMessage();
            }
        }
        
        function scrollToBottom(element) {
            if(element) element.scrollTop = element.scrollHeight;
        }

        function showEmptyState(title, subtitle = '') { DOMElements.chatArea.innerHTML = `<div class="empty-state"><i class="fas fa-comments"></i><h3>${title}</h3><p>${subtitle}</p></div>`; }
        function escapeHtml(text) { return text ? document.createElement('div').appendChild(document.createTextNode(text)).parentNode.innerHTML : ''; }
        function formatTime(dateString) { const date = new Date(dateString); return date.toLocaleTimeString('fr-FR', { hour: '2-digit', minute: '2-digit' }); }

        // --- MODAL FUNCTIONS (Unchanged) ---
        function openConversationsModal() { /* ... */ }
        function closeConversationsModal() { /* ... */ }
        function displayConversations(conversations) { /* ... */ }
        function openContactsModal() { /* ... */ }
        function closeContactsModal() { /* ... */ }
        function displayContacts(contacts) { /* ... */ }
        function filterList(type, query) { /* ... */ }

        window.addEventListener('beforeunload', () => {
            if (state.realtimeChannel) supabase.removeChannel(state.realtimeChannel);
        });
    </script>
</body>
</html>
